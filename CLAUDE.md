# Project: MyCastle

## Overview
Web base application use to manage and agregate personal information data.

## Key Objectives / Current Focus
Projekt składa się z aplikacji backend i frontend

Aplikacja backend:
- napisana w node.js
- Składa się z następujących modułów
    - filesystem
        - wczytujący i zapisujący stan danych do plików
        - Dla szybszych operacji odczytu pliki przechowywane są w pamięci
        - Działający w katalogu o root dir w env rootDir
    - mqttserver
        - Server mqtt wysyłający/odbierajacy json
        - Definiujący klasę Client bo serwer może mieć wiele clientów
        - Zawierający klasę Packet która definiuje typy pakietów,
        - Zawierający klasy pakietów dla każdego z typów, serializuje/deserializuje pakiety, waliduje pakiety, wysyła oraz odbiera pakiety
    - httpserver
        - HttpUploadServer - serwer HTTP (port 3001) z CORS
        - Endpointy: POST /upload (pliki binarne), GET /files/ (serwowanie plików z data/public/)
        - POST /ocr - skanowanie paragonów przez Tesseract.js OCR
        - GET /ocr/status - sprawdzenie dostępności OCR
    - ocr
        - OcrService - Tesseract.js z preprocessingiem Sharp (grayscale, normalize, sharpen, threshold)
        - Inicjalizacja non-blocking — jeśli Tesseract nie może się zainicjalizować, reszta backendu działa
        - Język: polski (pol.traineddata, ~15MB, pobierany automatycznie przy pierwszym użyciu)
        - PolishReceiptParser - regex parser tekstu OCR z polskich paragonów (produkty, ceny, rabaty, suma, data, sklep)

Aplikacja frontend 
- aplikacja react w ts
- aplikacja mająca wygląd podobny do tej w aplikacjach google (min google cloud)
- wykożystująca Material UI i ikony material
- definiująca następujące moduły
    - mqttclient - połaczenie mqtt z aplikacja backend
    - filesystem - moduł odpowiedzialny za obsługę funkcjonalności filesystem
        - data/ - klasy danych runtime (DirData, FileData)
        - models/ - interfejsy modeli danych JSON (DirModel, FileModel, ProjectModel, TaskModel)
        - nodes - klasy wewnętrznego stanu modeli np TaskNode
          - zawirają pola jak w models ale z uzupełnieniem w wewnętrzny stan aplikacji
          - implementują często używaną funkcjonalność
        - components/ - klasy danych plików json te bardziej zagnieżdżone (FileComponent, DirComponent, FileJsonComponent)
        - FilesystemService - serwis do operacji I/O
        - FilesystemContext - React Context do zarządzania stanem
    - uiforms - moduł systemu UI inspirowany Godotem
        - models/ - interfejsy modeli danych
          - UIControlModel - bazowy model kontrolki z anchors, offsets, presets, sizeFlags
          - UIFormModel - model formularza (root control, settings, callbacks, dataSchema)
          - UILayoutModels - modele kontenerów (VBox, HBox, Grid, Tabs, Accordion)
          - UIInputModels - modele kontrolek (Label, Button, Input, Checkbox, Select...)
          - UIPickerModels - modele picker'ów danych (PersonPicker, TaskPicker, ProjectPicker)
        - nodes/ - klasy Node z UI state
          - UIControlNode extends NodeBase
        - renderer/ - renderowanie drzewa kontrolek
          - UIFormRenderer - główny renderer formularza
          - UIControlRenderer - renderer pojedynczej kontrolki
          - UIAnchorLayout - system CSS dla anchors/offsets (Godot-like positioning)
          - controls/ - implementacje kontrolek
            - containers/ - UIVBox, UIHBox, UIGrid, UIScroll, UIMargin
            - basic/ - UILabel, UIButton, UIInput, UITextarea, UICheckbox, UIRadio, UISelect
            - pickers/ - UIPersonPicker, UITaskPicker, UIProjectPicker
            - advanced/ - UITabs, UIAccordion, UISlider, UIProgress, UITable
            - registry.ts - rejestr komponentów
        - designer/ - visual designer (drag & drop)
          - UIFormDesigner - główny komponent designera
          - UIDesignerCanvas - canvas z dropzones
          - UIDesignerToolbox - paleta kontrolek
          - UIDesignerProperties - panel właściwości
          - UIDesignerTree - drzewo hierarchii
          - UIDesignerContext - context stanu designera
          - hooks/ - useDragDrop, useSelection, useHistory (undo/redo)
        - binding/ - data binding
          - UIFormContext - context danych formularza
          - useUIBinding - hook reaktywnego bindingu (oneWay, twoWay, oneTime)
          - UICallbackRegistry - rejestr callback'ów (onClick, onChange, onSubmit)
        - services/
          - UIFormService - CRUD dla formularzy (load/save z data/ui_forms.json)
    - Automate - graficzny język programowania wzorowany na NodeRed
      - Wykonywanie skryptów JavaScript
      - Aktualnie działa na froncie ale w przyszłości na backendzie też
      - Udostępniający wykonywanym skryptom proste api do systemu aktualne dokumentacja interfejsu powinna być w pliku docs/automate.md
      - Posiadający graficzny interfejs użytkownika - graficzne łączenie nodów, okna właściwości nodów
      - Zapisujący flow do pliku w filesystem
    - ai - moduł integracji z modelami AI
      - models/ - interfejsy (AiConfigModel, AiProviderConfig, AiChatRequest, AiChatResponse, AiToolDefinition, AiToolCall)
      - providers/ - abstrakcja providerów AI z tool calling
        - AiProvider - interfejs providera
        - OpenAiProvider - OpenAI + Custom (OpenAI-compatible), tool calling
        - AnthropicProvider - Anthropic Claude, tool use (translacja formatów)
        - OllamaProvider - Ollama (local), tool calling (OpenAI-compatible)
      - services/
        - AiService - zarządzanie konfiguracją i wywołaniami AI (singleton: aiService)
      - Konfiguracja: data/ai_config.json (provider, apiKey, baseUrl, defaultModel, defaults)
      - Integracja z Automate: api.ai (chat, chatMessages, isConfigured) + node LLM Call
      - Tool calling: obsługa tools/tool_choice w request, toolCalls w response
    - speech - moduł syntezy i rozpoznawania mowy (TTS/STT/Wake Word)
      - models/ - interfejsy (SpeechConfigModel, TtsConfig, SttConfig, WakeWordConfig, TtsRequest, SttResponse)
      - providers/ - abstrakcja providerów
        - TtsProvider/SttProvider - interfejsy
        - OpenAiTtsProvider - OpenAI TTS API
        - BrowserTtsProvider - Web Speech API (speechSynthesis)
        - OpenAiSttProvider - OpenAI Whisper API
        - BrowserSttProvider - Web Speech API (SpeechRecognition)
      - services/
        - SpeechService - zarządzanie konfiguracją i wywołaniami TTS/STT (singleton: speechService)
        - AudioRecorder - wrapper na MediaRecorder API
        - WakeWordService - detekcja frazy aktywacyjnej (singleton: wakeWordService)
      - components/ - reużywalne komponenty React
        - SpeakButton - przycisk TTS
        - MicrophoneButton - przycisk STT z nagrywaniem
        - WakeWordIndicator - wskaźnik nasłuchiwania wake word
      - Konfiguracja: data/speech_config.json (tts, stt, wakeWord)
      - Integracja z Automate: api.speech (say, stop) + nody TTS/STT
    - conversation - moduł konwersacji z tool calling i scenariuszami
      - models/ - interfejsy (ConversationAction, ConversationMessage, ConversationScenario, ConversationConfig, ContextInjector)
      - actions/ - rejestr i wbudowane akcje konwersacyjne
        - ActionRegistry - rejestr akcji (register, execute, toToolDefinitions)
        - taskActions - CRUD tasków (list, get, create, update, delete, search)
        - calendarActions - eventy kalendarza (list_events_today, list_events_date, search_events)
        - fileActions - operacje plikowe (read_file, write_file, list_directory)
        - personActions - osoby (list_persons, get_person)
        - projectActions - projekty (list_projects, get_project)
        - navigationActions - nawigacja po aplikacji (navigate_to, get_available_pages)
        - automateActions - automatyzacje (list_flows, run_flow)
        - initActions - inicjalizacja z dependency injection (DataSource, NavigateFunction)
      - engine/ - silnik konwersacji
        - ConversationEngine - pętla tool calling z obsługą scenariuszy, context injectors, confirmation flow
      - services/
        - ConversationService - zarządzanie konfiguracją i scenariuszami (singleton: conversationService)
        - ConversationHistoryService - persystencja historii konwersacji (singleton: conversationHistoryService)
      - Konfiguracja: data/conversation_config.json (agentMode, scenarios, maxToolCallsPerTurn, historyLimit)
      - Historia: data/conversation_history.json (messages, scenarioId)
      - Dokumentacja akcji: docs/conversation.md
      - Rozszerza AI module o tool calling (AiToolDefinition, AiToolCall) dla OpenAI, Anthropic, Ollama
      - Rozszerza Castle Agent o tryb agentowy, selektor scenariuszy, UI tool calls, dialog potwierdzenia
    - shopping - moduł zakupów i skanowania paragonów
      - models/ - interfejsy
        - ReceiptModels - ReceiptData, ReceiptItem, ReceiptScanStatus
        - ReceiptScanConfigModel - ReceiptScanEngine ('ai_vision' | 'local_ocr' | 'hybrid'), ENGINE_LABELS, ENGINE_DESCRIPTIONS
      - services/ - provider pattern dla skanowania paragonów
        - ReceiptScanProvider - interfejs providera (scan(imageBlobs) → ReceiptData)
        - AiVisionReceiptProvider - wysyła zdjęcia do AI vision (multimodal), sprawdza aiService.isConfigured() przed skanowaniem
        - LocalOcrReceiptProvider - wysyła zdjęcia do backendu POST /ocr (Tesseract.js), bez AI
        - HybridReceiptProvider - OCR na backendzie + tekst do AI (tańsze niż AI Vision, lepsze niż samo OCR)
        - ReceiptScannerService - deleguje do wybranego providera, loadConfig/saveConfig z data/receipt_scan_config.json (singleton: receiptScannerService)
      - Konfiguracja: data/receipt_scan_config.json (engine)
      - Komunikacja z backendem OCR: HTTP (nie MQTT) — MQTT ma limit 2MB i hardcoded 30s timeout
      - URL backendu HTTP: z VITE_HTTP_URL (nie VITE_HTTP_UPLOAD_URL) — ważne dla dostępu z urządzeń mobilnych

- definiuje następujące reużywalne komponenty react
      - editor - kod tekstowego edytora plików
      - mdeditor - edytor drag and drop edytora markdown podobny do notion 
        - rozszerzenia edytora markdown (mdeditor)
          - UIFormExtension - osadzanie formularzy UI w markdown
          - format referencji: @[uiform:form-id]
          - format inline: @[uiform:{...json...}]
          - slash command: /form
    - integracja z markdownConverter.ts (serializacja/deserializacja)
      - upload - ui dodawania plików do systemu
      - person, project, task - ui zwiazany z PersonModel.ts, PersonNode.ts, ProjectModel.ts, ProjectNode.ts, TaskModel.ts, TaskNode.ts
        - dane z następujących model:
          - PersonModel z pliku /data/data/persons
          - TaskModel z pliku /data/data/tasks
          - ProjectModel z pliku /data/data/projects
        - natępujące typy model
          - Label
            - wygladem przypomina przycisk z ikoną typu np Person
            - nie edytowalny
            - majacy props: (id np z PersonModel)
          - Picker np. PersonPicker
            - wygladem przypomina przycisk z ikoną typu np Person
            - majacy props: editable, id (id np z PersonModel)
            - gdy editable po kliknieciu wywołujacy modal z możliwością wyboru
      - ObjectSearch - widok przeszukujący obiekty w DataSource na podstawie ich właściwości (możliwośc dodania warunków and, or, not),
      zwracający liste
- składa się z następujących stron
    - /filesystem/save - formularz zapisujący dane do pliku
    - /filesystem/list - widok podzielony z lewej drzewo danych po pliknieciu 
    - /person - widok edycji person bazuje na /components/person/PersonListEditor.ts
    - /project - widok edycji project bazuje na /components/project/ProjectListEditor.ts
    - /calendar - widok kalendarza z AI Day Planner
    - /settings/ai - konfiguracja providera AI (OpenAI, Anthropic, Ollama, Custom)
    - /settings/speech - konfiguracja TTS, STT i Wake Word
    - /settings/receipt - konfiguracja silnika skanowania paragonów (AI Vision / Lokalne OCR / Hybrydowe), test dostępności OCR backend
    - /shopping - listy zakupów z skanowaniem paragonów (aparat/plik → OCR/AI → przegląd → import do listy)
    - /agent - Castle Agent - głosowy asystent AI z Wake Word, STT, LLM i TTS (pipeline: wake word → nagrywanie → transkrypcja → AI → synteza mowy), tryb agentowy z tool calling, scenariusze konwersacyjne, persystencja historii
    - /todolist - widok z taskami do zrobienia
    - /components - widok demonstrujący reużywalne komponenty UI te z katalogów person, project, task
    - /editor/simple/{path} - wydok na bełny ekran edytora monaco do edycji plików z filesystem: json, md
    - /viewer/md/{path} - renderowanie zawartości plików md
    pobierz dane i wyswietl, po prawej widok wczytanych danych
    - /objectviewer - oparty na podstawie ObjectSearch wyświetlający listę objektów
    - /designer/ui/:id - visual designer formularzy UI (drag & drop)
    - /viewer/ui/:id - podgląd formularza UI
    - /automate - lista flow automatyzacji
    - /designer/automate/:id - visual designer flow automatyzacji (NodeRed-like)

## Directory Structure
- `src/backend/`: Backend source code (TypeScript)
  - `modules/filesystem/`: File system module with in-memory cache
  - `modules/mqttserver/`: MQTT server with Client and Packet classes
  - `modules/httpserver/`: HTTP server (upload, file serving, OCR endpoints)
  - `modules/ocr/`: OCR module (Tesseract.js + Sharp + PolishReceiptParser)
  - `types/`: TypeScript type definitions
- `src/client/`: Frontend React application (TypeScript)
  - `src/modules/mqttclient/`: MQTT client module
  - `src/modules/filesystem/`: Filesystem module
    - `data/`: Data classes (DirData, FileData)
    - `models/`: Model interfaces (DirModel, FileModel, ProjectModel, TaskModel)
    - `nodes/` : nodes class extend models of additional states and functions
    - `components/`: components class (FileComponent, DirComponent, FileJsonComponent)
  - `src/modules/uiforms/`: UI Forms module (Godot-like)
    - `models/`: UIControlModel, UIFormModel, UILayoutModels, UIInputModels, UIPickerModels
    - `nodes/`: UIControlNode extends NodeBase
    - `renderer/`: UIFormRenderer, UIControlRenderer, UIAnchorLayout
      - `controls/`: containers/, basic/, pickers/, advanced/, registry.ts
    - `designer/`: UIFormDesigner, UIDesignerCanvas, UIDesignerToolbox, UIDesignerProperties
    - `binding/`: UIFormContext, useUIBinding, UICallbackRegistry
    - `services/`: UIFormService
  - `src/modules/automate/`: Automate module (NodeRed-like visual programming)
    - `models/`: AutomateFlowModel, AutomateNodeModel, AutomateEdgeModel, AutomatePortModel
    - `nodes/`: AutomateFlowNode extends NodeBase
    - `registry/`: nodeTypes (NODE_TYPE_METADATA - node type definitions)
    - `engine/`: AutomateEngine, AutomateSandbox, AutomateSystemApi
    - `designer/`: AutomateDesigner, AutomateDesignerContext, Toolbox, Properties, Toolbar
      - `components/`: AutomateBaseNode (custom ReactFlow node)
    - `services/`: AutomateService (CRUD, data/automations.json)
  - `src/modules/ai/`: AI module (universal provider abstraction + tool calling)
    - `models/`: AiModels (AiConfigModel, AiProviderConfig, AiChatRequest, AiChatResponse, AiToolDefinition, AiToolCall)
    - `providers/`: AiProvider interface, OpenAiProvider, AnthropicProvider, OllamaProvider
    - `services/`: AiService (config load/save, chat, testConnection)
  - `src/modules/conversation/`: Conversation module (tool calling + scenarios)
    - `models/`: ConversationModels (ConversationAction, ConversationMessage, ConversationScenario, ConversationConfig)
    - `actions/`: ActionRegistry, taskActions, calendarActions, fileActions, personActions, projectActions, navigationActions, automateActions, initActions
    - `engine/`: ConversationEngine (tool calling loop)
    - `services/`: ConversationService, ConversationHistoryService
  - `src/modules/speech/`: Speech module (TTS/STT/Wake Word)
    - `models/`: SpeechModels (SpeechConfigModel, TtsConfig, SttConfig, WakeWordConfig)
    - `providers/`: TtsProvider, SttProvider, OpenAiTtsProvider, BrowserTtsProvider, OpenAiSttProvider, BrowserSttProvider
    - `services/`: SpeechService, AudioRecorder, WakeWordService
    - `components/`: SpeakButton, MicrophoneButton, WakeWordIndicator
  - `src/pages/agent/`: Castle Agent page (voice assistant with Wake Word + STT + AI + TTS)
  - `src/pages/automate/`: Automate pages (list, designer)
  - `src/pages/designer/`: calendar pages
  - `src/pages/designer/`: test components pages
  - `src/pages/editor/`: editor pages
  - `src/pages/objectviewer/`: objectviewer pages
  - `src/pages/person/`: person pages
  - `src/pages/project/`: project pages
  - `src/pages/todolist/`: todolist pages
  - `src/pages/viewer/`: viewer pages
  - `src/pages/filesystem/`: Filesystem pages (save, list)
  - `src/pages/designer/`: UI Designer pages
  - `src/components/`: Reusable UI components
    - `person/` - components of PersonModel
    - `project/` - components of ProjectModel
    - `task/` - components of TaskModel
  - `src/components/mdeditor/extensions/`: Markdown editor extensions
    - `UIFormExtension.tsx` - embedding UI forms in markdown
- `tests/`: Automated tests
- `docs/`: Project documentation
- `configs/`: Configuration files (YAML, JSON, .env, etc.)
- `scripts/`: Utility / automation scripts
- `assets/`: Images, fonts, or other static resources
- `dist/`: Compiled backend code
- `data/`: Runtime data directory (configurable via ROOT_DIR env)
  - `ui_forms.json`: UI Forms definitions (UIFormsModel)
  - `automations.json`: Automate flow definitions (AutomateFlowsModel)
  - `ai_config.json`: AI provider configuration (AiConfigModel)
  - `speech_config.json`: Speech (TTS/STT/Wake Word) configuration (SpeechConfigModel)
  - `conversation_config.json`: Conversation module configuration (ConversationConfig, scenarios)
  - `conversation_history.json`: Persisted conversation history (ConversationHistoryModel)

## Development Workflow & Commands
- **Setup:** `npm install` (backend), `cd src/client && npm install` (frontend)
- **Run backend:** `npm run dev` (API on 3001, MQTT on 1893)
- **Run frontend:** `cd src/client && npm start`
- **Test:** `npm test`
- **Lint/Format:** `eslint .`
- **Build:** `npm run build`

## Code Style & Principles
### General
- **Formatting:** Enforce automated formatting/linting (Prettier)
- **Naming:** cammel case
- **Documentation:** Keep docstrings/comments focused on **"why"**, not **"what"**
- **Modularity:** Functions/components/services should have a single responsibility
- **Imports/dependencies:** Prefer clarity over brevity; avoid hidden magic

### Language/Stack Specific
Typescript with imports

## Environment & Dependencies
- **Languages/versions:** Node 20, TypeScript
- **Package manager:** npm
- **Frontend Framework:** React with TypeScript, Material UI
- **Backend Libraries:** Aedes (MQTT), dotenv
- **External services:** MQTT broker

## Common Gotchas
- **General:** Don't hardcode secrets; always use environment configs.
- **TypeScript:** Ensure proper type definitions for MQTT and filesystem operations to avoid runtime errors.
- **MQTT:** Use unique client IDs to avoid connection conflicts.
- **Frontend:** Handle async operations (e.g., MQTT subscriptions) properly in React components.
